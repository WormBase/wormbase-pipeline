#!/usr/bin/perl

use strict;
use Wormbase;
use Wormtest;
use Log_files;
use Getopt::Long;

my ($debug, $test, $database, $species, $log_file, $prev_release, $store);
my ($recent_citace, $primary_seq_dumps, $elegans_first, $build_contents, $dna_headers, $split_gffs,
    $tier2_contigs, $masked_files, $blat_files, $homology_loaded, $tier2_blat_contigs, $est_dat,
    $cache_size, $uniprot_ids, $vep, $dbxref, $final_gff, $species_merge, $composition);
GetOptions(
    'debug=s'            => \$debug,
    'test'               => \$test,
    'database:s'         => \$database,
    'species:s'          => \$species,
    'logfile:s'          => \$log_file,
    'prev_release:s'     => \$prev_release,
    'store:s'            => \$store,
    'recent_citace'      => \$recent_citace, # checks citace dump is less than 3 weeks old
    'primary_seq_dumps'  => \$primary_seq_dumps, #checks cDNA dumps are present
    'elegans_first'      => \$elegans_first, # checks that elegans database has been loaded if attempting to load another species database
    'build_contents'     => \$build_contents, # checks expected folders and files are in build directory
    'dna_headers'        => \$dna_headers, # checks DNA FASTA files all have headers
    'split_gffs:s'       => \$split_gffs, # checks that all expected split GFF files are present
    'composition'        => \$composition, # checks that the DNA composition matches the previous release (elegans only)
    'tier2_contigs:s'    => \$tier2_contigs, # checks that non-elegans GFF files have the required number of sequence-regions
    'masked_files'       => \$masked_files, # checks for presence of masked cDNA files
    'blat_files'         => \$blat_files, # checks for presence of BLAT files
    'homology_loaded'    => \$homology_loaded, # checks that homology data has been loaded 
    'est_dat'            => \$est_dat, # checks for presence of EST feature files, creating dummy files if appropriate
    'cache_size'         => \$cache_size, # checks cache2 size for briggsae
    'uniprot_ids'        => \$uniprot_ids, # checks that uniprot IDs have been added to wormpep files
    'vep'                => \$vep, # checks that ace file has been generated by the VEP pipeline
    'dbxref'             => \$dbxref, # checks that the DBxref report file is present and is correctly formatted
    'final_gff'          => \$final_gff, # checks that final GFF dumps are present
    'species_merge'      => \$species_merge # checks that species have been successfully merged
    );

my $wormbase;
if ($store) {
    $wormbase = retrieve($store) or croak("can't restore wormbase from store\n");
}
else {
    $wormbase = Wormbase->new(
	-test     => $test,
	-debug    => $debug,
	-organism => $species,
	-autoace  => $database
	);
}

my $log = $log_file ? Log_files->make_log($log_file, $debug) : Log_files->make_build_log($wormbase);

my $wormtest = Wormtest->make_build_tester($wormbase, $log, $prev_release);

my $errors;
if ($recent_citace) {
    $errors += $wormtest->recent_citace_dump;
}
if ($primary_seq_dumps) {
    $errors += $wormtest->primary_seq_dumps_present;
}
if ($elegans_first) {
    $errors += $wormtest->elegans_loaded_first;
}
if ($build_contents) {
    $errors += $wormtest->build_folder_contents_present;
}
if ($dna_headers) {
    $errors += $wormtest->dna_files_have_headers;
}
if ($split_gffs) {
    $split_gffs = lc($split_gffs);
    die "Value passed to -split_gffs parameter must be one of 'init', 'blat', 'homol', or 'variation\n"
	unless $split_gffs eq 'init' or $split_gffs eq 'blat'
	or $split_gffs eq 'homol' or $split_gffs eq 'variation';
    $errors += $wormtest->split_gffs_present($split_gffs);
}
if ($composition) {
    $errors += $wormtest->dna_composition_unchanged;
}
if ($tier2_contigs) {
    die "Value passed to -tier2_contigs parameter must be either 'init' or 'blat'\n"
	unless $tier2_contigs eq 'init' or $tier2_contigs eq 'blat';
    $errors += $wormtest->tier2_contigs_dumped($tier2_contigs);
}
if ($masked_files) {
    $errors += $wormtest->masked_files_present;
}
if ($blat_files) {
    $errors += $wormtest->blat_files_present;
}
if ($homology_loaded) {
    $errors += $wormtest->homology_data_loaded;
}
if ($est_dat) {
    $errors += $wormtest->create_est_dat_files_if_required;
}
if ($cache_size) {
    $errors += $wormtest->cache_size_sufficient;
}
if ($uniprot_ids) {
    $errors += $wormtest->uniprot_ids_in_wormpep;
}
if ($vep) {
    $errors += $wormtest->vep_output_present;
}
if ($dbxref) {
    $errors += $wormtest->dbxref_report_correctly_formatted;
}
if ($final_gff) {
    $errors += $wormtest->final_gff_dumps_present;
}
if ($species_merge) {
    $errors += $wormtest->species_merge_successful;
}

$log->log_and_die("**** WARNING: $errors errors identified by run_build_tests.pl ****\n") if $errors;

$log->mail;

exit(0);
